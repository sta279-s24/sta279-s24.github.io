---
title: "Homework 3"
output: 
  rmdformats::robobook:
    css: "homework.css"
    highlight: pygments
link-citations: yes
---

**Due:** Friday, February 9, 2:00pm on Canvas

**Instructions:** 

* Download the [HW 3 template](https://sta279-s24.github.io/homework/hw_3_template.qmd), and open the template (a Quarto document) in RStudio. 
* Put your name in the file header
* Click `Render`
* Type all code and answers in the document (using `###` for section headings and `####` for question headings)
* Render early and often to catch any errors!
* When you are finished, submit the final rendered HTML to Canvas

**Code guidelines:**

* If a question requires code, and code is not provided, you will not receive full credit
* You will be graded on the quality of your code. In addition to being correct, your code should also be easy to read
  * No magic numbers
  * Use descriptive names for your variables
  * Set seeds where needed
  * Comment code
  * If a block of code is being called multiple times, put it in a function
  
**Resources:** In addition to the class notes and activities, I recommend reading the following resources:

* [Chapter 5](https://adv-r.hadley.nz/control-flow.html) (loops and choices) in *Advanced R*
* [Appendix C.2](https://mdsr-book.github.io/mdsr3e/C-algorithmic.html#simple-example) in *Modern Data Science with R*
* [Chapter 19.1 -- 19.5.2](https://r4ds.had.co.nz/functions.html) (functions and conditions) in *R for Data Science* (1st edition)


### Practice with functions

The Huber loss function is defined as 

$$\psi(x) = \begin{cases} x^2 & \text{if } |x| \leq 1 \\ 2|x| - 1 & \text{if } |x| > 1  \end{cases}$$

This function is quadratic on the interval $[-1,1]$, and linear outside of this interval. It transitions from quadratic to linear "smoothly", and it is often used in place of the usual squared error loss for robust estimation. 


:::{.question}
#### Question 1

Write a function `huber()` that takes as an input a number $x$, and returns the Huber value $\psi(x)$. Here is a code skeleton to get you started:

```r
huber <- function(x){

}
```

*Hint:* The `ifelse` function from class will be helpful!
:::


:::{.question}
#### Question 2

HW 1 introduced the idea of *vectorization*. The `ifelse` function is vectorized, so if you used the `ifelse` function in Question 4, your `huber` function should also be vectorized.

Check that the function is vectorized: e.g., `huber(c(0.5, 1, 2))` should return `0.25 1.00 3.00`
:::

The Huber function can be modified so that the transition from quadratic to linear happens at an arbitrary cutoff value $a$, as in:

$$\psi_a(x) = \begin{cases} x^2 & \text{if } |x| \leq a \\ 2a|x| - a^2 & \text{if } |x| > a  \end{cases}$$

:::{.question}
#### Question 3

Starting with your solution code to Question 2, update your `huber()` function so that it takes two arguments: $x$, a number at which to evaluate the loss, and $a$ a number representing the cutoff value. It should now return $\psi_a(x)$, as defined above. Make $a = 1$ the *default* in your `huber` function.
:::

### More practice with functions

Neural networks are a way to learn complex prediction models. Fundamentally, a neural network works by passing input data through a series of nodes; the output of one layer of nodes is the input for the next layer. Each time the data goes through a node, an *activation function* is applied to transform the output (this allows the network to model nonlinear relationships).

Common activation functions include the ReLU (rectified linear unit):

$$f(x) = \begin{cases} x & x > 0 \\ 0 & x \leq 0 \end{cases}$$
and the *leaky* ReLU, with parameter $a$:

$$f_a(x) = \begin{cases} x & x > 0 \\ a \cdot x & x \leq 0 \end{cases}$$
Indeed, the ReLU could be considered a special case of the leaky ReLU with $a = 0$. 

Here is an implementation of the ReLU function in R:

```{r}
relu <- function(x){
  if(x > 0){
    return(x)
  } else {
    return(0)
  }
}
```

This `relu` function works for single inputs:

```{r}
relu(1)
relu(-1)
```

However, it does not work for vectors of length greater than 1:

```{r, error=T}
relu(c(1, -1))
```

The issue here is that `if(x > 0)` in the `if...else...` statement is not vectorized. That is, R is expecting a single true or false, not a vector. To vectorize this function we can use the `ifelse` function (which IS vectorized).

:::{.question}
#### Question 4

Re-write the `relu` function above, using the `ifelse` function, so that `relu` can be applied to vectors.
:::

:::{.question}
#### Question 5

Adapt your `relu` function from Question 4 to create a new function, `leaky_relu`, which takes TWO inputs, $x$ and $a$, and returns $f_a(x)$ as defined above. Make $a = 0$ the default value.
:::


### More power simulations

On the previous homework, you work on simulating data to assess power in linear regression models. For the simple linear regression model

$$Y_i = \beta_0 + \beta_1 X_i + \varepsilon_i$$
we consider testing $H_0: \beta_1 = 0$ vs. $H_A: \beta_1 \neq 0$.

*Power* is the probability we reject $H_0$, and it depends on the true value of $\beta_1$:

$$Power(\beta_1) = P(\text{reject } H_0 | \beta_1 \text{ is true slope})$$
Last time, you wrote code to calculate the power for a given value of $\beta_1$. This time, you will turn your code into a function.


:::{.question}
#### Question 6

Use your code from HW 2 to write function called `test_power`, with the following requirements:

Inputs:

* `n`: the number of observations from the linear regression model
* `nsim`: the number of simulations used to estimate the power
* `beta0`: the true intercept for the linear regression model
* `beta1`: the true slope for the linear regression model
* `alpha`: the p-value threshold for rejecting $H_0: \beta_1 = 0$

Output: an estimate of $Power(\beta_1)$
:::

:::{.question}
#### Question 7

Use your function from question 6 to calculate the power for different values of $\beta_1$ (0, -0.5, 0.5, -1, and 1) when $n = 100$ and $\alpha = 0.05$ (you may specify your own choice of `beta0` and `nsim`). How does power change as $\beta_1$ changes? Explain why this makes sense.
:::

:::{.question}
#### Question 8

Use your function from question 6 to calculate the power for different values of $n$ (10, 50, 100, 500) when $\alpha = 0.05$ and $\beta_1 = 0.5$ (you may specify your own choice of `beta0` and `nsim`). How does power change as $n$ changes? Explain why this makes sense.
:::


