---
title: "Homework 5 Solutions"
format: 
  html:
    embed-resources: true
editor: source
author: "Ciaran Evans"
---


#### Question 1

```{python}
import numpy as np

# create x
x = np.linspace(0, 1, 11)

# for loop version
x_square = np.zeros(11)
for i in range(11):
  x_square[i] = x[i]**2

x_square

# "vectorized" version
x_square = x**2
x_square

# list comprehension version
x_square = [a**2 for a in x]
x_square
```

#### Question 2 

```{python}
# create x
x = np.linspace(0, 2, 41)

# for loop version
x_square = np.zeros(11)
for i in range(11):
  x_square[i] = x[i]**2

x_square

# "vectorized" version
x_square = x**2
x_square

# list comprehension version
x_square = [a**2 for a in x]
x_square
```

#### Question 3

There are two different ways you could approach the problem here (the wording of the problem is slightly ambiguous). *I am fine with either approach*. 

The simpler approach is to have the robots pull simultaneously, in which case the game is fair (each robot wins 50% of the time):

```{python}
np.random.seed(321)

nsim = 1000
results = np.zeros(nsim)

for i in range(nsim):
  marker = 0
  
  while -0.5 < marker < 0.5:
    robotA = np.random.uniform(0, 0.5)
    robotB = np.random.uniform(0, 0.5)
    marker += robotA - robotB
    
  results[i] = marker >= 0.5

np.mean(results)
```

The slightly more complicated approach is to have the robots take *turns* pulling, and update the marker each time. Now there is a distinct advantage to robot A for pulling first.

#### Question 4 

```{python}
np.random.seed(111)

n_people = 100 # number of people in the theater
nsim = 1000 # number of simulations to estimate probability
results = np.zeros(nsim)
seats = np.arange(n_people)

for i in range(nsim):
  taken = np.zeros(n_people)
  
  choice = np.random.choice(seats)
  taken[choice] = 1
  
  for j in range(1, n_people - 1):
    if taken[j] == 0:
      taken[j] = 1
    else:
      choice = np.random.choice(seats[taken == 0])
      taken[choice] = 1
  
  results[i] = taken[n_people-1] == 0

np.mean(results)
```

**Notes:**

* Make sure to use difference indices for the two `for` loops! Here I have used `i` and `j`
* There are lots of other ways to code this question (e.g., you could use a counter to record the results, rather than a vector)
* It is crucial to treat the first person separately from the rest


#### Question 5


```{python}
def huber(x, a=1):
  return np.where(abs(x) <= a, x**2, 2*a*abs(x) - a**2)
```


#### Question 6 

```{python}
def leaky_relu(x, a=0):
  return np.where(x >= 0, x, a*x)
```