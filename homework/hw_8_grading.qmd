---
title: "Homework 8 grading"
format: 
  html:
    embed-resources: true
editor: source
author: "Ciaran Evans"
---

```{r}
library(tidyverse)
library(mdsr)
library(DBI)

db <- dbConnect_scidb("airlines")

query <- "
  SHOW TABLES;
"
dbGetQuery(db, query)
```

1. (6 pts)

```{sql connection=db}
SELECT 
  dest, SUM(1) as N
FROM flights
WHERE origin = 'ORD' AND year = 2010
GROUP BY dest
ORDER BY N DESC
LIMIT 0, 5;
```

**Grading:** 

* 1 pt for counting the number of flights
* 1 pt for grouping by destination
* 1 pt for displaying both the count and the destination in the output
* 1 pt for descending order
* 2 pts for choosing ORD and 2010

2. (5 pts)

```{sql connection=db}
SELECT 
  dest, AVG(arr_delay) as mean_arr_delay
FROM flights
WHERE year = 2010
GROUP BY dest
ORDER BY mean_arr_delay DESC
LIMIT 0, 5;
```

**Grading:** 

* 1 pt for calculating mean arrival delay
* 1 pt for grouping by destination
* 1 pt for displaying both the delay and the destination in the output
* 1 pt for descending order
* 1 pts for choosing 2010

3. (7 pts)

```{sql connection=db}
SELECT 
  name, AVG(arr_delay) as mean_arr_delay
FROM flights
JOIN airports ON flights.dest = airports.faa
WHERE year = 2010
GROUP BY dest
ORDER BY mean_arr_delay DESC
LIMIT 0, 5;
```

**Grading:** 

* 1 pt for calculating mean arrival delay
* 1 pt for grouping by destination
* 1 pt for displaying both the delay and the destination in the output
* 1 pt for descending order
* 1 pts for choosing 2010
* 2 pts for joining on dest = faa

4. (6 pts)

```{sql connection=db}
SELECT 
  SUM(cancelled) as N,
  SUM(cancelled)/SUM(1) AS prop_cancelled
FROM flights
WHERE year = 2010 AND 
  ((origin = 'JFK' AND dest = 'SFO') OR 
  (origin = 'SFO' AND dest = 'JFK'))
LIMIT 0, 5;
```

**Grading:** 

* 1 pt for calculating number of cancelled flights
* 1 pt for calculating proportion of cancelled flights
* 4 pt for year = 2010, AND correctly identifying flights between JFK and SFO (either JFK is origin and SFO is dest, or JFK is dest and SFO is origin)

5. This one is a bit more open-ended; student answers may vary (6 pts)

**Grading:** 

* 2 pts for answers that involve JFK, EWR, and LGA as the origin airports
* 2 pts for looking at something reasonable (arrival delay, departure delay, etc.)
* 2 pts for making a reasonable comparison between the airports

6. (17 pts)

```{r}
my_kmeans <- function(dat, k, max_iter){
  
  n <- nrow(dat) # number of observations
  
  # choose the initial means
  means <- dat[sample(1:n, k),]
  
  # calculate distances to the initial means
  dists <- matrix(nrow = n, ncol = k)
  for(i in 1:k){
    dists[,i] <- rowSums((sweep(as.matrix(dat), 2, as.matrix(means)[i,]))^2)
  }
  
  # initialize groups
  groups <- apply(dists, 1, which.min)
  
  # track the number of iterations and whether the groups have changed
  cur_iter <- 0
  group_change <- 1
  
  while(group_change > 0 & cur_iter < max_iter){
    
    # update the means
    for(i in 1:k){
      means[i,] <- colMeans(dat[groups == i,])
    }
    
    # update the distances
    dists <- matrix(nrow = n, ncol = k)
    for(i in 1:k){
      dists[,i] <- rowSums((sweep(dat, 2, means[i,]))^2)
    }
    
    # update the groups
    new_groups <- apply(dists, 1, which.min)
    
    cur_iter <- cur_iter + 1
    group_change <- sum(groups != new_groups)
    groups <- new_groups
  }
  
  return(list(means, groups))
}
```


```{r}
library(palmerpenguins)

clustering <- penguins |>
  select(flipper_length_mm, bill_length_mm) |>
  drop_na() |>
  as.matrix() |>
  my_kmeans(k=3, max_iter = 100)

penguins |>
  select(flipper_length_mm, bill_length_mm) |>
  drop_na() |>
  mutate(group = as.factor(clustering[[2]])) |>
  ggplot(aes(x = flipper_length_mm, y = bill_length_mm, color = group)) +
  geom_point()

```

**Grading:** If they didn't write this as a function, they lose 10 pts

* 3 pts for correct inputs (data, number of clusters, max iterations)
* 2 pts for correct output (cluster assignments and group means)
* 2 pts for correct initialization
* 2 pts for calculating distances
* 2 pts for assinging groups
* 2 pts for updating means
* 4 pts for iterating until convergence, or max iterations reached
